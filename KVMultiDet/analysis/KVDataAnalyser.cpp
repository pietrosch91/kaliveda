/*
$Id: KVDataAnalyser.cpp,v 1.40 2009/01/14 16:15:46 franklan Exp $
$Revision: 1.40 $
$Date: 2009/01/14 16:15:46 $
$Author: franklan $
*/

#include "KVBase.h"
#include "KVDataAnalyser.h"
#include "KVDataRepositoryManager.h"
#include "KVDataRepository.h"
#include "KVDataAnalysisTask.h"
#include "KVDataSetManager.h"
#include "KVDataSet.h"
#include "KVDataBase.h"
#include "KVDBSystem.h"
#include "KV2Body.h"
#include "KVDBRun.h"
#include "KVString.h"
#include "TObjString.h"
#include "TObjArray.h"
#include "Riostream.h"
#include "KVBatchSystemManager.h"
#include "TPluginManager.h"
#include "TSystemDirectory.h"
#include "TROOT.h"
#include "TClass.h"
#include "THashList.h"

using namespace std;
Bool_t KVDataAnalyser::fCleanAbort = kFALSE;

ClassImp(KVDataAnalyser)
//////////////////////////////////////////////////
// BEGIN_HTML <!--
/* -->
<h2>KVDataAnalyser</h2>
<h4>Set up and run data analysis tasks</h4>
<p>
This can be used either 'interactively' or in menu-driven mode.
In both cases, in order to run a data analysis task, the user must
specify:
</p>
<ul>
<li>the dataset to analyse</li>
<li>the type of analysis task to perform</li>
<li>the run or runs to analyse</li>
<li>whether to use a batch system to execute the analysis</li>
</ul>
<p>
The role of this base class is to set up the environment necessary for the execution of
a given data analysis task;
the actual analysis will be performed by a specialised child class of KVDataAnalyser as
specified by the task. See <a href="KVDataAnalysisTask.html">KVDataAnalysisTask</a>.
The available data analysers are defined as plugins in the file $KVROOT/KVFiles/.kvrootrc
as in the following example:
</p>
<pre>
# Plugins for data analysis
# KVDataAnalyser can be tuned for different datasets/environments
Plugin.KVDataAnalyser:   INDRA   KVINDRADataAnalyser KVIndra "KVINDRADataAnalyser()"
+Plugin.KVDataAnalyser:   INDRAReconData   KVINDRAReconDataAnalyser KVIndra "KVINDRAReconDataAnalyser()"
+Plugin.KVDataAnalyser:   INDRARawDataRecon   KVINDRARawDataReconstructor KVIndra "KVINDRARawDataReconstructor()"
+Plugin.KVDataAnalyser:   INDRAGeneDataAnalyser   KVINDRAGeneDataAnalyser KVIndra "KVINDRAGeneDataAnalyser()"
</pre>
<h4>Perform analysis tasks using text menus to choose data, task, runs, etc.</h4>

<pre>
KVDataAnalyser* datan = new KVDataAnalyser;
datan->RunMenus()
</pre>
  --- or ---
<pre>
gDataSetManager-><a href="KVDataSetManager.html#KVDataSetManager:RunAnalyser">RunAnalyser(...)</a>
</pre>

<h4>Perform analysis tasks "interactively"</h4>

<p>In an interactive ROOT session, type:</p>

<pre>
KVDataAnalyser* datan = new KVDataAnalyser;
datan->SetDataSet(...)
datan->SetAnalysisTask(...)
datan->SetRuns(...)
etc. etc.
</pre>

<p>to set up the analysis task. You can also mix 'interactive' and menus by calling</p>

<pre>
datan->ChooseDataSet()
datan->ChooseAnalysisTask()
datan->ChooseSystem()
datan->ChooseRuns(system)
</pre>

<p>Note that in this case the order is important: you cannot "ChooseAnalysisTask"
before choosing or setting a dataset. Note also that in order to use ChooseRuns()
you must give the pointer to the system (KVDBSystem*) to analyse.</p>

<p>To set the "running mode", i.e. whether to run in batch or not, you can use</p>
<pre>
datan->ChooseRunningMode()
</pre>
<p>to be asked to choose interactive or batch, and then (if required) a batch system.</p>
<p>If you don't use ChooseRunningMode() then use either:</p>
<pre>
datan->SetBatchSystem(0); // no batch
</pre>
<p>or, if you want to use a batch system, you can get a pointer to the required batch system
from the <a href="KVBatchSystemManager.html">batch system manager</a>:</p>
<pre>
KVBatchSystem *mybatch = gBatchSystemManager->GetBatchSystem(...)
</pre>
<p>define the batch properties (see <a href="KVBatchSystem.html">KVBatchSystem</a> and derived classes),</p>
<pre>
mybatch->SetJobName(...)
mybatch->SetMultiJobsMode(); // to run 1 job for each run
</pre>
<p>and then do</p>
<pre>
datan->SetBatchSystem( mybatch ); // run task in batch
</pre>
<p>When ready to perform the analysis, call</p>
<pre>
datan->Run()
</pre>
<p>You will be asked to supply any missing parameters for the analysis task.</p>

<h4>Naming user files generated by analysis in batch mode</h4>

<p>When running an analysis task using a batch system, the working directory where the
analysis is executed may be different to the one where the job was submitted. The source files
for any user-supplied analysis class are automatically copied to the working directory when
execution of the task begins. <b>Any</b> files generated by the user's analysis are copied back to the original directory at the end of
execution. In case several tasks are launched from the same directory, it is the user's responsibility
to give unique names to the files generated by her analysis. One simple way to do this is to
use the name of the batch job as a basis for naming such files (see <a href="KVBatchSystem.html">KVBatchSystem</a>):
</p>
<pre>
#include "KVBatchSystem.h"
...
if( gBatchSystem ) {
   //running in batch. name results file after job name.
   new TFile( Form( "%s.root", gBatchSystem->GetJobName() ), "recreate");
}
else {
   //not running in batch. fixed name.
   new TFile("Results.root", "recreate");
}
</pre>
<!-- */
// --> END_HTML
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

KVDataAnalyser* gDataAnalyser = 0;

KVDataAnalyser::KVDataAnalyser()
{
   //Default constructor.
   fParent = 0;
   fBatch = kFALSE;
   fTask = 0;
   fSystem = 0;
   fDataSet = 0;
   fQuit = kFALSE;
   fChoozDataSet = kTRUE;
   fChoozSystem = kFALSE;
   fChoozTask = kFALSE;
   fChoozRuns = kFALSE;
   fSubmit = kFALSE;
   nbEventToRead = -1;
   fUserClassIsOK = kFALSE;
   fUserClass = "";
   fBatchEnv = new TEnv(".KVBatchrc");
   if (!gBatchSystemManager) new KVBatchSystemManager;
   fBatchSystem = 0;
   fChoseRunMode = kFALSE;
   fWorkDirInit = fWorkDirEnd = 0;
   fMenus = kFALSE;
   fProofMode = EProofMode::None;
}

KVDataAnalyser::~KVDataAnalyser()
{
   //Default destructor.
   delete fBatchEnv;
   SafeDelete(fWorkDirInit);
   SafeDelete(fWorkDirEnd);
   if (gDataAnalyser == this)gDataAnalyser = 0;
}

void KVDataAnalyser::Reset()
{
   fDataSet = 0;
   fDataType = "";
   fRunList.Clear();
   fTask = 0;
   fSystem = 0;
   fQuit = kFALSE;
   fChoozDataSet = kTRUE;
   fChoozSystem = kFALSE;
   fChoozTask = kFALSE;
   fChoozRuns = kFALSE;
   fSubmit = kFALSE;
   fUserClassIsOK = kFALSE;
   fUserClass = "";
   fUserClassOptions = "";
   nbEventToRead = -1;
   fBatchSystem = 0;
   fChoseRunMode = kFALSE;
   fProofMode = EProofMode::None;
}

//_________________________________________________________________

void KVDataAnalyser::Run()
{
   //Check all task variables, then run analyser

   fSubmit = kFALSE;
   //print welcome message for main (parent) analyser
   if (!fParent && !fMenus) KVBase::PrintSplashScreen();

   if (CheckTaskVariables()) {
      if (fBatchSystem && !BatchMode()) {
         //if batch mode is requested, the job is submitted to the chosen batch system
         fBatchSystem->SubmitTask(this);
      } else {
         if (BatchMode() && fBatchSystem && !fParent) fBatchSystem->Print("log");
         if (!RunningInLaunchDirectory() && fParent) {
            //when batch job runs in directory different to launch directory,
            //we scan the list of files present in the current working directory
            //just prior to running the analysis task
            ScanWorkingDirectory(&fWorkDirInit);
         }
         //check connection to remote data repository, if needed
         if (fParent && gDataRepository->IsRemote() && !gDataRepository->IsConnected()) return;
         SubmitTask();
         if (!RunningInLaunchDirectory() && fParent) {
            //when batch job runs in directory different to launch directory,
            //we scan the list of files present in the current working directory
            //just after running the analysis task
            ScanWorkingDirectory(&fWorkDirEnd);
            //any files which are present in the second list which were not present
            //in the first list will be copied back to the launch directory
            CopyAnalysisResultsToLaunchDirectory();
         }
         if (BatchMode() && fBatchSystem && !fParent) {
            // at end of batch jobs,
            // remove .[jobname] and [jobname].status files from $HOME directory
            // remove .[jobname].bak and [jobname].status.bak files from $HOME directory
            TString ff;
            AssignAndDelete(ff, gSystem->ConcatFileName(gSystem->Getenv("HOME"), Form(".%s", GetBatchName())));
            gSystem->Unlink(ff);
            AssignAndDelete(ff, gSystem->ConcatFileName(gSystem->Getenv("HOME"), Form(".%s.bak", GetBatchName())));
            gSystem->Unlink(ff);
            AssignAndDelete(ff, gSystem->ConcatFileName(gSystem->Getenv("HOME"), Form("%s.status", GetBatchName())));
            gSystem->Unlink(ff);
            AssignAndDelete(ff, gSystem->ConcatFileName(gSystem->Getenv("HOME"), Form("%s.status.bak", GetBatchName())));
            gSystem->Unlink(ff);
         }
      }
   }
   fChoozDataSet = kTRUE;
   fBatchSystem = 0;
}

//_________________________________________________________________

void KVDataAnalyser::RunMenus()
{
   //Run data analyser in menu-driven mode

   fMenus = kTRUE;
   Reset();
   KVBase::PrintSplashScreen();

   fQuit = kFALSE;
   fChoozDataSet = kTRUE;
   fChoozSystem = kFALSE;
   fChoozTask = kFALSE;
   fChoozRuns = kFALSE;
   fSubmit = kFALSE;

   while (!fQuit) {

      if (fChoozDataSet)
         ChooseDataSet();
      else if (fChoozTask)
         ChooseAnalysisTask();
      else if (fChoozSystem)
         ChooseSystem();
      else if (fChoozRuns)
         ChooseRuns();
      else if (fSubmit) {
         Run();
         Reset();
         KVBase::PrintSplashScreen();
      }
   }
}

//_________________________________________________________________

Bool_t KVDataAnalyser::CheckTaskVariables()
{
   //Checks the task variables
   //In batch mode, we first set the task variables by reading the
   //batch env file associated with the name set for the batch job

   if (BatchMode()) ReadBatchEnvFile(Form(".%s", GetBatchName()));

   if (!fDataSet) {
      ChooseDataSet();
      if (!fDataSet) {
         //if after calling ChooseDataSet we STILL don't have a dataset,
         //there is something seriously wrong...
         Error("CheckTaskVariables", "By the pricking of my thumb, something wicked this way comes...");
         Error("CheckTaskVariables", "                        *** ABORTING THE ANALYSIS ***");
         return kFALSE;
      }
   }

   if (!fTask) {
      ChooseAnalysisTask();
   }

   if (fRunList.IsEmpty()) {
      ChooseSystem();
      ChooseRuns();
   }

   if (fTask->WithUserClass() && fUserClass != ClassName()) {
      //task requires user analysis class
      if (fUserClass == "") {
         ChooseUserClass();
      }

      while (!CheckIfUserClassIsValid()) {
         cout << "============> Warning <=============" << endl;
         cout << GetUserClass() << " is not a valid " << fTask->GetUserBaseClass() << endl;
         cout << "Analysis aborted." << endl;
         cout << "====================================" << endl;
         if (BatchMode()) return kFALSE; // avoid infinite loop in batch mode
         ChooseUserClass();
      }
   }

   if (nbEventToRead < 0) {
      ChooseNbEventToRead();
   }

   return kTRUE;
}

//_________________________________________________________________

void KVDataAnalyser::ChooseDataSet()
{
   //Print list of available datasets and get user to choose one
   //A pointer to the chosen dataset can be retrieved with GetDataSet()

   //not possible in batch mode
   if (BatchMode()) return;

   fChoozDataSet = kFALSE;
   fQuit = kFALSE;
   fDataSet = 0;
   if (fTask) {
      fTask = 0;
   }

   cout << "Available datasets :" << endl << endl;
   gDataSetManager->Print("available");
   Int_t n_dataset = -1;
   Int_t n_avail = gDataSetManager->GetNavailable();

   if (n_avail < 1) {
      //no datasets available - force termination
      fQuit = kTRUE;
      return;
   }

   if (n_avail == 1) {
      //1 dataset available - automatic choice
      n_dataset = 1;
   } else {
      KVString tmp;
      while (!fQuit && (n_dataset < 1 || n_dataset > n_avail)) {
         cout << endl << "Your choice (1-" << gDataSetManager->
              GetNavailable() << ")";
         if (fMenus) cout << " [q - quit]";
         cout << " : ";
         tmp.ReadLine(cin);
         if (fMenus && (tmp.Contains("q") || tmp.Contains("Q"))) {
            fQuit = kTRUE;
            return;
         } else if (tmp.IsDigit()) {
            n_dataset = tmp.Atoi();
         }
      }
   }
   //we have chosen a dataset
   fDataSet = gDataSetManager->GetAvailableDataSet(n_dataset);
   //in menu-driven mode, next step is choice of analysis task
   fChoozTask = kTRUE;
}

//_________________________________________________________________

void KVDataAnalyser::ChooseDataType()
{
   //Print list of available types of data for the chosen dataset
   //and get user to choose one.

   //not possible in batch mode
   if (BatchMode()) return;

   fChoozTask = kFALSE;
   fQuit = kFALSE;
   fChoozSystem = kFALSE;
   fChoozDataSet = kFALSE;
   fTask = 0;
   fDataType = "";

   fDataSet->Print("data");
   cout << endl << "Choose data type [d - change dataset | q - quit] : ";
   TString tmp;
   while (!fQuit && !fChoozDataSet && !fChoozSystem) {

      tmp.ReadLine(cin);
      if (tmp == "raw" || tmp == "recon" || tmp == "ident"
            || tmp == "root") {
         fChoozSystem = kTRUE;
         fDataType = tmp;
      } else if (tmp.Contains("q") || tmp.Contains("Q")) {
         fQuit = kTRUE;
      } else if (tmp.Contains("d") || tmp.Contains("D")) {
         fChoozDataSet = kTRUE;
      }

   }
}

//_________________________________________________________________

void KVDataAnalyser::ChooseAnalysisTask()
{
   //Print list of all possible data analysis tasks for the chosen data set and invite the user
   //to choose one of them.
   //If only one task available, it is automatically selected

   //not possible in batch mode
   if (BatchMode()) return;

   fChoozTask = kFALSE;
   fTask = 0;
   fDataType = "";
   if (fSystem) {
      fSystem = 0;
   }

   cout << endl << "Available data analysis tasks :" << endl << endl;
   fDataSet->Print("tasks");
   Int_t n_tasks = fDataSet->GetNtasks();
   if (n_tasks == 1) {
      SetAnalysisTask(fDataSet->GetAnalysisTask(1));
      fChoozSystem = kTRUE;
      return;
   }

   Int_t n_task = -1;
   KVString tmp;

   while (!fQuit && (n_task < 1 || n_task > n_tasks)) {
      cout << endl << "Your choice (1-" << n_tasks <<
           ")";
      if (fMenus) cout << " [d - change dataset | q - quit]";
      cout << " : ";
      tmp.ReadLine(cin);
      if (fMenus && (tmp.Contains("q") || tmp.Contains("Q"))) {
         fQuit = kTRUE;
         return;
      } else if (fMenus && (tmp.Contains("d") || tmp.Contains("D"))) {
         fChoozDataSet = kTRUE;
         return;
      } else if (tmp.IsDigit()) {
         n_task = tmp.Atoi();
      }
   }
   SetAnalysisTask(fDataSet->GetAnalysisTask(n_task));
   //in menu-driven mode, next step is choice of system
   fChoozSystem = kTRUE;
}

//_________________________________________________________________

void KVDataAnalyser::ChooseSystem(const Char_t* data_type)
{
   //Print out list of all available systems for the given data type of the chosen dataset
   //and invite the user to choose one. Return pointer to chosen system.
   //If 'data_type' is not given, we assume that ChooseAnalysisTask was previously
   //called and we use the prerequisite data type for the chosen task (fTask->GetPrereq()).
   //The available system list is deduced from the 'availableruns' file corresponding to the
   //chosen dataset repository subdirectory and the
   //chosen data type (="raw", "recon", "ident", "root").

   //not possible in batch mode
   if (BatchMode()) return;

   fChoozSystem = kFALSE;
   fSystem = 0;
   ClearRunList();

   //if no systems are defined for the dataset, we just want to pick from the runlist
   if (!fDataSet->GetDataBase()->GetTable("Systems")->GetRecords()->GetSize()) {
      fChoozRuns = kTRUE;
      return;
   }

   TString d_t(data_type);
   //If 'data_type' is not given, we assume that ChooseAnalysisTask or ChooseDataType
   //was previously called and we use the value of fDataType
   if (d_t == "")
      d_t = fDataType;

   TList* sys_list = fDataSet->GetListOfAvailableSystems(d_t.Data());
   if (!sys_list || sys_list->GetSize() < 1) {
      cout << "No systems found for dataset: " << fDataSet->
           GetName() << ", datatype: " << d_t.Data() << endl;
      if (sys_list)
         delete sys_list;
      //choose a different data type or analysis task
      fChoozTask = kTRUE;
      return;
   }
   TIter next_sys(sys_list);
   KVDBSystem* sys;
   int nsys = 0;
   cout << endl << "Available systems : " << endl << endl;
   while ((sys = (KVDBSystem*) next_sys())) {
      nsys++;
      cout << "     " << Form("%3d.", nsys);
      cout << " " << Form("%-30s", sys->GetName());
      cout << " (" << Form("%-3d",
                           sys->GetNumberRuns()) << " runs)" << endl;
   }

   if (sys_list->GetSize() == 1) {
      fChoozRuns = kTRUE;
      fSystem = (KVDBSystem*) sys_list->At(0);
      delete sys_list;
      return;
   }

   int nsys_pick = -1;
   KVString tmp;

   fQuit = fChoozTask = fChoozRuns = kFALSE;

   while (!fQuit && !fChoozTask && !fChoozRuns && !fChoozDataSet) {
      cout << endl << "Your choice (1-" << nsys << ")";
      if (fMenus) {
         cout << " [r - choose runs | "; //ignore systems list & choose from all runs
         if (fTask)
            cout << "t - change task";
         else
            cout << "t - change type";
         cout << " | d - change dataset | q - quit]";
      }
      cout << " : ";
      tmp.ReadLine(cin);
      if (fMenus && (tmp.Contains("q") || tmp.Contains("Q"))) {
         fQuit = kTRUE;
      } else if (fMenus && (tmp.Contains("t") || tmp.Contains("T"))) {
         fChoozTask = kTRUE;
      } else if (fMenus && (tmp.Contains("d") || tmp.Contains("D"))) {
         fChoozDataSet = kTRUE;
      } else if (fMenus && (tmp.Contains("r") || tmp.Contains("R"))) {
         fChoozRuns = kTRUE;
         delete sys_list;
         return;
      } else if (tmp.IsDigit()) {
         nsys_pick = tmp.Atoi();
         if (nsys_pick >= 1 && nsys_pick <= nsys)
            fChoozRuns = kTRUE;
      }
   }
   if (fChoozRuns)
      fSystem = (KVDBSystem*) sys_list->At(nsys_pick - 1);
   delete sys_list;
}

//_________________________________________________________________

void KVDataAnalyser::ChooseRuns(KVDBSystem* system,
                                const Char_t* data_type)
{
   //Print out list of available runs for chosen dataset, task/data type and system
   //and invite user to choose from among them
   //If 'data_type' is not given, we assume that ChooseAnalysisTask was previously
   //called and we use the prerequisite data type for the chosen task (fTask->GetPrereq()).
   //If 'system' is not given, we assume ChooseSystem was previously called and use
   //the internally-stored value of that choice (fSystem).

   //not possible in batch mode
   if (BatchMode()) return;

   fChoozRuns = kFALSE;
   //clear any previous list of runs
   fRunList.Clear();

   if (system)
      fSystem = system;

   KVString d_t(data_type);
   //If 'data_type' is not given, we assume that ChooseAnalysisTask or ChooseDataType
   //was previously called and we use the value of fDataType
   if (d_t == "")
      d_t = fDataType;

   if (fSystem) {
      cout << endl << "  Chosen system : " << endl;
      fSystem->Print();
   }
   cout << endl << endl << "  Available runs: " << endl << endl;

   KVNumberList all_runs = PrintAvailableRuns(d_t);

   if (all_runs.IsEmpty()) {
      //no runs - choose another system
      fChoozSystem = kTRUE;
      return;
   }

   cout << endl << "Enter list of runs [a - all";
   if (fMenus) {
      cout << " | ";
      if (fSystem) cout << "s - change system | ";
      if (fTask)
         cout << "t - change task";
      else
         cout << "t - change type";
      cout << " | d - change dataset | q - quit";
   }
   cout << "] : ";
   TString tmp;
   tmp.ReadLine(cin);
   if (fMenus && (tmp.Contains("q") || tmp.Contains("Q"))) {
      fQuit = kTRUE;
   } else if (fMenus && (tmp.Contains("s") || tmp.Contains("S"))) {
      fChoozSystem = kTRUE;
   } else if (fMenus && (tmp.Contains("t") || tmp.Contains("T"))) {
      fChoozTask = kTRUE;
   } else if (fMenus && (tmp.Contains("d") || tmp.Contains("D"))) {
      fChoozDataSet = kTRUE;
   } else if (tmp.Contains("a") || tmp.Contains("A")) {
      fRunList = all_runs;
      fSubmit = kTRUE;
   } else {
      //cout << "YOU TYPED : " << tmp.Data() << endl;
      KVNumberList user_list(tmp.Data());
      //cout << "YOUR LIST : " << user_list.GetList() << endl;
      //cout << "CLEARED RUNLIST : " <<  endl; fRunList.PrintLimits();
      //remove from list any runs which did not actually appear in list
      user_list.Begin();
      while (!user_list.End()) {
         Int_t user_run = user_list.Next();
         if (all_runs.Contains(user_run)) fRunList.Add(user_run);
      }
      //cout << "CHECKED RUNLIST : " <<  endl; fRunList.PrintLimits();
      if (fRunList.IsEmpty()) {
         Error("ChooseRuns" ,
               "None of the runs you chose appear in the list");
         //we force the user to choose again
         fChoozRuns = kTRUE;
      } else
         fSubmit = kTRUE;
   }
   if (fSubmit)
      cout << endl << "Chosen runs : " << fRunList.GetList() << endl;
}

//_________________________________________________________________

void KVDataAnalyser::SetDataSet(KVDataSet* ds)
{
   //Set dataset to be used for analysis.
   //If the chosen dataset is not available, an error message is printed
   //Only available datasets can be analysed
   //Moreover, only datasets in the currently active data repository,
   //gDataRepository, can be analysed. This is also checked.

   //allow user to reset dataset pointer to 0
   fDataSet = ds;
   if (!ds)
      return;

   //check availablility
   if (!ds->IsAvailable()) {
      Error("SetDataSet",
            "Dataset %s is not available for analysis", ds->GetName());
      fDataSet = 0;
   }
   //check repository
   if (ds->GetRepository() != gDataRepository) {
      Error("SetDataSet",
            "%ld is address of dataset in repository \"%s\", not of the dataset in the current repository, \"%s\"",
            (ULong_t) ds, ds->GetRepository()->GetName(),
            gDataRepository->GetName());
      fDataSet = 0;
   }
}

//_________________________________________________________________

void KVDataAnalyser::SetDataSet(const Char_t* name)
{
   //Set dataset to be analysed.
   //If 'name' is not the name of a valid and available dataset
   //in the currently active data repository, gDataRepository,
   //an error message is printed.

   fDataSet = 0;
   KVDataSet* ds = gDataSetManager->GetDataSet(name);
   if (!ds) {
      Error("SetDataSet", "Unknown dataset %s", name);
   } else {
      SetDataSet(ds);
   }
}

//_________________________________________________________________

void KVDataAnalyser::SetAnalysisTask(KVDataAnalysisTask* at)
{
   //Set analysis task and data type
   //For ways of obtaining pointers to data analysis tasks for any given dataset,
   //see method KVDataSet::GetAnalysisTask(const Char_t* keywords) const.
   fTask = at;
   if (at)
      fDataType = at->GetPrereq();
}

//_________________________________________________________________

KVNumberList KVDataAnalyser::PrintAvailableRuns(KVString& datatype)
{
   //Prints list of available runs for selected dataset, data type/analysis task, and system
   //Returns list containing all run numbers

   KVNumberList all_runs =
      fDataSet->GetRunList(datatype.Data(), fSystem);
   KVDBRun* dbrun;
   all_runs.Begin();
   while (!all_runs.End()) {
      dbrun = (KVDBRun*)fDataSet->GetDataBase()->GetTable("Runs")->GetRecord(all_runs.Next());
      if (dbrun) {
         cout << "    " << Form("%4d", dbrun->GetNumber());
         cout << Form("\t(%7d events)", dbrun->GetEvents());
         cout << "\t[File written: " << dbrun->GetDatime().AsString() << "]";
         if (dbrun->GetComments())
            cout << "\t" << dbrun->GetComments();
         cout << endl;
      }
   }

   return all_runs;
}

//_________________________________________________________________

void KVDataAnalyser::SetSystem(KVDBSystem* syst)
{
   // Set the System used in the analysis

   fSystem = syst;
}

//_________________________________________________________________

void KVDataAnalyser::SetRuns(const Char_t* rl, Bool_t check)
{
   //Sets the run list (string has format of a KVNumberList)
   //If check=kTRUE (default), we check that the runs are available, and if they belong to different
   //systems we print a warning message
   KVNumberList tmp(rl);
   SetRuns(tmp, check);
}

//_________________________________________________________________

void KVDataAnalyser::SetRuns(KVNumberList& nl, Bool_t check)
{
   // Sets the run list
   //If check=kTRUE (default), we check that the runs are available, and if they belong to different
   //systems we print a warning message
   if (!fDataSet) {
      Warning("SetRuns", "Data Set not defined... Nothing done");
      return;
   }
   if (!check) {
      fRunList = nl;
      //set fSystem using first run
      KVDBRun* run = (KVDBRun*)fDataSet->GetDataBase()->GetTable("Runs")->GetRecord(nl.First());
      if (run) fSystem = run->GetSystem();
      else fSystem = 0;
      return;
   }
   // Check if all runs are available for this data set and if they all correspond to the same system
   Int_t i = 0;
   Info("SetRuns", "Checking runs %s for Data type %s",
        nl.AsString(), fDataType.Data());
   nl.Begin();
   fRunList.Clear();
   while (!nl.End()) {
      Int_t run_no = nl.Next();

      if (!(fDataSet->CheckRunfileAvailable(fDataType.Data(), run_no))) {
         Warning("SetRuns",
                 "The run %d is not present for the data type \"%s\" of data set \"%s\".",
                 run_no, fDataType.Data(), fDataSet->GetName());
      } else {
         fRunList.Add(run_no);
      }
      KVDBRun* run = (KVDBRun*)fDataSet->GetDataBase()->GetTable("Runs")->GetRecord(run_no);
      if (!i) {
         fSystem = run->GetSystem();
         i = 1;
      } else {
         if (run->GetSystem() != fSystem) {
            if (fSystem)
               Warning("SetRuns",
                       "The system \"%s\" of run %d differs from the system \"%s\" of the previous runs.",
                       run->GetSystem()->GetName(), run_no, fSystem->GetName());
         }
      }
   }
   Info("SetRuns", "Accepted runs : %s", fRunList.AsString());
}

//_________________________________________________________________

void KVDataAnalyser::SetUserIncludes(const Char_t* incDirs)
{
// Add to the includes paths the user's includes paths
// the includes paths have to be separated by a white space

   fIncludes = "";
   if (!incDirs) {
      return;
   }
   TString tmp = incDirs;
   TString curIncDir = gSystem->GetIncludePath();
   TObjArray* oa = tmp.Tokenize(" ");
   oa->SetOwner(kTRUE);
   TIter next(oa);
   TObjString* st = 0;
   while ((st = (TObjString*)next())) {
      TString id = st->GetString();
      if (id.Length()) {
         fIncludes += id.Data();
         fIncludes += " ";
         if (!curIncDir.Contains(id.Data())) {
            cout << "Include path \"" << id.Data() << "\" added." << endl;
            id.Prepend("-I");
            gSystem->AddIncludePath(id.Data());
         }
      }
   }
   delete oa;
}

//_________________________________________________________________

void KVDataAnalyser::SetUserLibraries(const Char_t* libs)
{
// Load the user's libraries
// the libraries have to be separated by a white space

   fLibraries = "";
   if (!libs) {
      return;
   }
   KVString tmp = libs;
   KVString slib = gSystem->GetLibraries("", "D");

   tmp.Begin(" ");
   while (!tmp.End()) {

      KVString id = tmp.Next();

      Bool_t loaded = kFALSE;
      slib.Begin(" ");
      while (!slib.End() && !loaded) {
         KVString ss = slib.Next();
         if (ss == id) {
            Info("SetUserLibraries", "%s already load", id.Data());
            loaded = kTRUE;
         } else {
         }
      }
      if (!loaded) {
         Info("SetUserLibraries", "Library \"%s\"added.", id.Data());
         gSystem->Load(id.Data());
      }
      fLibraries += id.Data();
      fLibraries += " ";
   }

}

//__________________________________________________________________________________//

void KVDataAnalyser::ChooseNbEventToRead()
{
   // Ask user to set number of events to read

   SetNbEventToRead(-1);
   while (nbEventToRead < 0) {
      cout << "Give the number of events to read [<RET>=all]:" << endl;
      KVString ntr;
      ntr.ReadToDelim(cin);
      if (ntr.IsDigit() || !ntr.Length()) {
         if (ntr.Length()) {
            nbEventToRead = (Long64_t) ntr.Atoi();
         } else {
            nbEventToRead = 0;
         }
      } else {
         cout << "\"" << ntr.
              Data() << "\" is not a number. Please retry." << endl;
      }
   }
}

//__________________________________________________________________________________//

KVDataAnalyser* KVDataAnalyser::GetAnalyser(const Char_t* plugin)
{
   //Creates an instance of a class derived from KVDataAnalyser defined as a plugin

   //check and load plugin library
   TPluginHandler* ph;
   if (!(ph = KVBase::LoadPlugin("KVDataAnalyser", plugin)))
      return 0;

   //execute constructor
   KVDataAnalyser* da = (KVDataAnalyser*) ph->ExecPlugin(0);

   return da;
}

//__________________________________________________________________________________//

void KVDataAnalyser::ChooseUserClass()
{
   //Choose the user's analysis class
   fUserClass = "";
   while (!fUserClass.Length()) {
      cout << "Give the name of the analysis class derived from " << fTask->GetUserBaseClass() << ":" << endl;
      fUserClass.ReadLine(cin);
      fUserClassIsOK = kFALSE;
   }
}

//__________________________________________________________________________________//

Bool_t KVDataAnalyser::DoUserClassFilesExist()
{
   //Check if files containing user's class are present in the working directory.
   //The names of the implementation and header files are stored in fUserClassImp and fUserClassDec.

   return KVBase::FindClassSourceFiles(fUserClass.Data(), fUserClassImp, fUserClassDec);
}

//__________________________________________________________________________________//

Bool_t KVDataAnalyser::CheckIfUserClassIsValid(const KVString& alternative_base_class)
{
   //Return kTRUE if the name of the class given by the user (fUserClass) is valid
   //for the analysis task. This is so if one of the following is true:
   //  - the class library has already been loaded. In this case the class will exist
   //    in the dictionary (gROOT->GetClass()); we check if it derived from the
   //    base class defined for the analysis task
   //  - a plugin exists defining this class as an extension of the base class defined
   //    for the analysis task (gROOT->GetPluginManager()->FindHandler(...): the URI for
   //    the plugin must be the same as the name of the class)
   //  - source files for the class are present in the working directory. In this case
   //    we can add a plugin handler for the class.
   //In the latter two cases, the class is valid if compilation succeeds.
   //
   //If the user's class may in fact be derived from an alternative base class, rather
   //than the base class defined for this analysis task (see KVDataAnalysisTask::SetUserBaseClass)
   //you can supply the name of this class.

   TObject* o = GetInstanceOfUserClass(alternative_base_class);
   if (o) {
      delete o;
      return kTRUE;
   }
   return kFALSE;
}

//__________________________________________________________________________________//

const Char_t* KVDataAnalyser::GetACliCMode()
{
   // Returns string to be appended to name of user class for compilation with ACliC in
   // GetInstanceOfUserClass. This depends on the boolean resources:
   //
   // KVDataAnalyser.UserClass.Debug:  ( "yes" => "g" )
   // KVDataAnalyser.UserClass.Optimise:   ( "yes" =>  "O" )
   // KVDataAnalyser.UserClass.ForceRecompile:  ( "no" => "+"; "yes" => "++" )
   //
   // Note that if both Debug and Optimise are set to "yes/true", we use Debug mode.
   // (can't have BOTH debug & optimisation).

   static TString aclic;
   if (gEnv->GetValue("KVDataAnalyser.UserClass.ForceRecompile", kFALSE)) aclic = "++";
   else aclic = "+";
   if (gEnv->GetValue("KVDataAnalyser.UserClass.Debug", kFALSE)) aclic += "g";
   else if (gEnv->GetValue("KVDataAnalyser.UserClass.Optimise", kFALSE)) aclic += "O";
   return aclic.Data();
}

//__________________________________________________________________________________//

TObject* KVDataAnalyser::GetInstanceOfUserClass(const KVString& alternative_base_class)
{
   //Return an instance of the class given by the user (fUserClass), if it is valid.
   //If the user class is given in the form of source code, it will be (re)compiled
   //if it has not already been loaded and/or the source has changed since the last
   //build, using ACliC. If the resource
   //
   //  KVDataAnalyser.UserClass.Debug:    yes
   //
   //is set, the user's class will be compiled with extra debugging information
   //
   //Once compiled, we check that the user's class is indeed derived from the base
   //class defined for this analysis task (see KVDataAnalysisTask::SetUserBaseClass).
   //If the user's class may in fact be derived from an alternative base class, you
   //can supply the name of this class.

   // make sure any required plugin library defining base class for user's analysis class is loaded
   if (!fTask->CheckUserBaseClassIsLoaded()) return 0x0;

   //do we have a plugin ?
   TPluginHandler* ph = gROOT->GetPluginManager()->FindHandler(fTask->GetUserBaseClass(), fUserClass.Data());
   if (!ph) {//no plugin defined

      //if it is a precompiled class (i.e. already part of KaliVeda),
      //it will be in the dictionary already
      TClass* cl = gROOT->GetClass(fUserClass.Data());

      //do we have source files ?
      if (DoUserClassFilesExist()) {
         //compile & load user's source files using ACLIC. ACliC options read by GetACliCMode() from .kvrootrc
         TString cmd;
         cmd.Form(".L %s%s", fUserClassImp.Data(), GetACliCMode());
         gROOT->ProcessLine(cmd.Data());
         //class will be in dictionary if compilation successful
         cl = gROOT->GetClass(fUserClass.Data());
      } else if (!cl) {
         //class not in dictionary and no source files. help!
         Info("GetInstanceOfUserClass", "Class %s is unknown and no source files available",
              fUserClass.Data());
         return 0;
      }
      if (!cl) {
         //compilation of user class has failed
         Info("GetInstanceOfUserClass", "Compilation of class %s failed. Correct the mistakes and try again",
              fUserClass.Data());
         return 0;
      }
      if (!cl->GetBaseClass(fTask->GetUserBaseClass())) {
         //class does not inherit from correct base
         if (alternative_base_class == "" || !cl->GetBaseClass(alternative_base_class)) {
            if (alternative_base_class != "")
               Info("GetInstanceOfUserClass", "Class %s does not inherit from correct base class (%s or %s), or compilation of class %s failed. Correct the mistakes and try again",
                    fUserClass.Data(), fTask->GetUserBaseClass(), alternative_base_class.Data(), fUserClass.Data());
            else
               Info("GetInstanceOfUserClass", "Class %s does not inherit from correct base class (%s), or compilation of class %s failed. Correct the mistakes and try again",
                    fUserClass.Data(), fTask->GetUserBaseClass(), fUserClass.Data());
            return nullptr;
         }
      }
      //EVERYTHING OK!! now instanciate an object of the new class
      return (TObject*)cl->New();
   } else {
      Info("GetInstanceOfUserClass", "Found plugin handler for class %s",
           fUserClass.Data());
      //load class from plugin
      ph = KVBase::LoadPlugin(fTask->GetUserBaseClass(), fUserClass.Data());
      if (!ph) {
         Info("GetInstanceOfUserClass", "KVBase::LoadPlugin failed for %s", fUserClass.Data());
         return 0;
      }
      TObject* obj = (TObject*)ph->ExecPlugin(0);
      if (obj) {
         //Info("GetInstanceOfUserClass", "constructor OK for %s", fUserClass.Data());
         if (obj->InheritsFrom(fTask->GetUserBaseClass())) return obj;
         Info("GetInstanceOfUserClass", "%s does not inherit from %s", fUserClass.Data(), fTask->GetUserBaseClass());
         return 0;
      } else {
         Info("GetInstanceOfUserClass", "constructor not OK for %s", fUserClass.Data());
         return 0;
      }
   }
   return 0;
}

//__________________________________________________________________________________//

void KVDataAnalyser::SetUserClass(const Char_t* kvs, Bool_t check)
{
   //Set name of user analysis class.
   //If check=kTRUE (default), we check the validity of the class
   //if check=kFALSE we do not check and assume that the class is valid

   fUserClass = kvs;
   if (check) {
      fUserClassIsOK = CheckIfUserClassIsValid();
   } else {
      fUserClassIsOK = kTRUE;
   }
}

//__________________________________________________________________________________//

void KVDataAnalyser::WriteBatchEnvFile(const Char_t* jobname, Bool_t save)
{
   //Save (in the TEnv fBatchEnv) all necessary information on analysis task which can be used to execute it later
   //(i.e. when batch processing system executes the job).
   //If save=kTRUE (default), write the information in a file whose name is given by ".jobname"
   //where 'jobname' is the name of the job as given to the batch system.

   delete fBatchEnv;
   fBatchEnv = new TEnv(Form(".%s", jobname));
   if (fBatchSystem) {
      fBatchEnv->SetValue("BatchSystem", fBatchSystem->GetName());
      fBatchSystem->WriteBatchEnvFile(fBatchEnv);
   }
   fBatchEnv->SetValue("DataRepository", gDataRepository->GetName());
   fBatchEnv->SetValue("DataSet", fDataSet->GetName());
   fBatchEnv->SetValue("AnalysisTask", fTask->GetType());
   fBatchEnv->SetValue("Runs", fRunList.GetList());
   if (fTask->WithUserClass()) {
      fBatchEnv->SetValue("UserClass", GetUserClass());
      if (fUserClassImp == "" || fUserClassDec == "") {
         if (!DoUserClassFilesExist()) {
            Warning("WriteBatchEnvFile", "Source files for user class %s do not exist. Job will not work.",
                    GetUserClass());
         }
      }
      fBatchEnv->SetValue("UserClassOptions", fUserClassOptions);
      fBatchEnv->SetValue("UserClassImp", fUserClassImp);
      fBatchEnv->SetValue("UserClassDec", fUserClassDec);
   }
   fBatchEnv->SetValue("NbToRead", (Double_t)nbEventToRead);
   fBatchEnv->SetValue("LaunchDirectory", gSystem->WorkingDirectory());
   if (fIncludes.Length()) {
      fBatchEnv->SetValue("UserIncludes", fIncludes.Data());
   }
   if (fLibraries.Length()) {
      fBatchEnv->SetValue("UserLibraries", fLibraries.Data());
   }

   if (save) fBatchEnv->SaveLevel(kEnvUser);
}

//_________________________________________________________________

Bool_t KVDataAnalyser::ReadBatchEnvFile(const Char_t* filename)
{
   //Read the batch env file "filename" and initialise the analysis task using the
   //informations in the file
   //Returns kTRUE if all goes well

   Bool_t ok = kFALSE;

   delete fBatchEnv;
   fBatchEnv = new TEnv(filename);
   TString val = fBatchEnv->GetValue("DataRepository", "");
   if (val != "") {
      gDataRepositoryManager->GetRepository(val.Data())->cd();
   } else {
      Error("ReadBatchEnvFile", "Name of data repository not given");
      return ok;
   }
   val = fBatchEnv->GetValue("DataSet", "");
   if (val != "") {
      gDataSetManager->GetDataSet(val.Data())->cd();
      SetDataSet(gDataSet);
   } else {
      Error("ReadBatchEnvFile", "Name of dataset not given");
      return ok;
   }
   val = fBatchEnv->GetValue("AnalysisTask", "");
   fTask = 0;
   if (val != "") {
      SetAnalysisTask(gDataSet->GetAnalysisTask(val.Data()));
   } else {
      Error("ReadBatchEnvFile", "Name of analysis task not given");
      return ok;
   }
   if (!fTask) {
      Error("ReadBatchEnvFile", "Analysis task \"%s\"not found for dataset %s",
            val.Data(), gDataSet->GetName());
      return ok;
   }
   val = fBatchEnv->GetValue("Runs", "");
   if (val != "") {
      KVNumberList runs(val.Data());
      SetRuns(runs);
   } else {
      Error("ReadBatchEnvFile", "List of runs not given");
      return ok;
   }
   nbEventToRead = (Long64_t)fBatchEnv->GetValue("NbToRead", -1);
   SetUserIncludes(fBatchEnv->GetValue("UserIncludes", ""));
   SetUserLibraries(fBatchEnv->GetValue("UserLibraries", ""));

   //batch system
   if (strcmp(fBatchEnv->GetValue("BatchSystem", ""), "")) {
      fBatchSystem = gBatchSystemManager->GetBatchSystem(fBatchEnv->GetValue("BatchSystem", ""));
      fBatchSystem->ReadBatchEnvFile(fBatchEnv);
      fBatchSystem->cd(); // make gBatchSystem point to it
      fBatchSystem->SetAnalyser(this);
   }

   //User files
   if (fTask->WithUserClass()) {
      fUserClass = fBatchEnv->GetValue("UserClass", "");
      if (fUserClass == "") {
         Error("ReadBatchEnvFile", "Name of user class not given");
         return ok;
      }
      fUserClassOptions = fBatchEnv->GetValue("UserClassOptions", "");
      fUserClassImp = fBatchEnv->GetValue("UserClassImp", "");
      if (fUserClassImp == "") {
         Error("ReadBatchEnvFile", "Name of user class implementation file not given");
         return ok;
      }
      fUserClassDec = fBatchEnv->GetValue("UserClassDec", "");
      if (fUserClass == "") {
         Error("ReadBatchEnvFile", "Name of user class header file not given");
         return ok;
      }
      //If current working directory is not the same as the launch directory,
      //we have to copy the user's files here
      if (!RunningInLaunchDirectory()) {
         TString launchDir = fBatchEnv->GetValue("LaunchDirectory", gSystem->WorkingDirectory());
         TString path_src, path_trg;
         //copy user's implementation file
         AssignAndDelete(path_src, gSystem->ConcatFileName(launchDir.Data(), fUserClassImp.Data()));
         AssignAndDelete(path_trg, gSystem->ConcatFileName(gSystem->WorkingDirectory(), fUserClassImp.Data()));
         gSystem->CopyFile(path_src.Data(), path_trg.Data());
         //copy user's header file
         AssignAndDelete(path_src, gSystem->ConcatFileName(launchDir.Data(), fUserClassDec.Data()));
         AssignAndDelete(path_trg, gSystem->ConcatFileName(gSystem->WorkingDirectory(), fUserClassDec.Data()));
         gSystem->CopyFile(path_src.Data(), path_trg.Data());
      }
   }

   ok = kTRUE;

   return ok;
}

//_________________________________________________________________

Bool_t KVDataAnalyser::RunningInLaunchDirectory()
{
   //Returns kTRUE if current working directory is same as launch directory for batch job
   //When not in batch mode, always returns kTRUE.
   if (!BatchMode() || !fBatchEnv) return kTRUE;
   TString launchDir = fBatchEnv->GetValue("LaunchDirectory", gSystem->WorkingDirectory());
   return (launchDir == gSystem->WorkingDirectory());
}

//_________________________________________________________________

void KVDataAnalyser::SubmitTask()
{
   //In interactive mode, the data analysis task is performed by
   //instanciating and initialising the KVDataAnalyser child class specified by the task,
   //and then calling its Run() method.
   //In batch mode, the job is submitted to the chosen batch system.

   KVString task_data_analyser = fTask->GetDataAnalyser();
   Info("SubmitTask", "fTask->GetDataAnalyser()=%s", task_data_analyser.Data());
   KVDataAnalyser* the_analyser = 0;
   if (task_data_analyser == "UserClass") {
      //the user-provided class is to be used as analyser
      the_analyser = (KVDataAnalyser*)GetInstanceOfUserClass();
   } else {
      the_analyser = GetAnalyser(fTask->GetDataAnalyser());
   }
   if (!the_analyser)
      Fatal("SubmitTask", "the_analyser is 0x0, go to crash");

   the_analyser->SetParent(this);
   the_analyser->SetDataSet(fDataSet);
   the_analyser->SetAnalysisTask(fTask);
   the_analyser->SetSystem(fSystem);
   the_analyser->SetRuns(fRunList, kFALSE);
   the_analyser->SetNbEventToRead(GetNbEventToRead());
   the_analyser->SetUserIncludes(fIncludes.Data());
   the_analyser->SetUserLibraries(fLibraries.Data());
   if (fTask->WithUserClass()) {
      the_analyser->SetUserClass(GetUserClass(), kFALSE);
      the_analyser->SetUserClassOptions(fUserClassOptions);
   } else if (strcmp(fTask->GetUserBaseClass(), "")) the_analyser->SetUserClass(fTask->GetUserBaseClass(), kFALSE);
   if (!BatchMode()) {
      //when not in batch mode i.e. when submitting a task, we ask the user to supply
      //any further information required by the task, and then ask whether to run in
      //interactive or batch mode
      the_analyser->CheckTaskVariables();
      if (!fChoseRunMode) ChooseRunningMode();
   }
   the_analyser->SetBatchMode(BatchMode());
   the_analyser->SetBatchName(GetBatchName());
   the_analyser->SetBatchSystem(fBatchSystem);
   the_analyser->SetProofMode(GetProofMode());
   //set global pointer to analyser object which performs the analysis
   //this allows e.g. user class to obtain information on the analysis task
   gDataAnalyser = the_analyser;
   the_analyser->Run();

   delete the_analyser;
}

//__________________________________________________________________________________//

const Char_t* KVDataAnalyser::ExpandAutoBatchName(const Char_t* format)
{
   //Replace any 'special' symbols in "format" with their current values
   //
   //  $Date   : current date and time
   //  $System  :  name of system to be analysed
   //  $User  :  name of user
   //  $UserClass  :  name of user's analysis class

   static KVString tmp;
   tmp = format;
   KVString sysname = SystemBatchName();
   tmp.ReplaceAll("$System", SystemBatchName());
   TDatime now;
   KVString stDate = now.AsSQLString();
   stDate.ReplaceAll(" ", "-");
   tmp.ReplaceAll("$Date", stDate.Data());
   if (fUserClass.Length()) tmp.ReplaceAll("$UserClass", fUserClass.Data());
   else if (fTask) tmp.ReplaceAll("$UserClass", fTask->GetDataAnalyser());
   tmp.ReplaceAll("$User", gSystem->GetUserInfo()->fUser.Data());
   return tmp.Data();
}

//__________________________________________________________________________________//

const Char_t* KVDataAnalyser::SystemBatchName()
{
   // Private method used by ExpandAutoBatchName to build name for current system
   // to be used in batch job name
   // Also used by KVDataAnalysisLauncher::SystemBatchName for batch job names
   // and for writing resources in .KVDataAnalysisGUIrc file

   static KVString tmp;
   tmp = "Unknown";
   if (!fSystem) return tmp.Data();
   return fSystem->GetBatchName();
}

const Char_t* KVDataAnalyser::GetLaunchDirectory() const
{
   // Returns full path to job submission directory for batch jobs.
   // Returns current working directory for non-batch jobs.

   if (!BatchMode() || !fBatchEnv) return gSystem->WorkingDirectory();
   return fBatchEnv->GetValue("LaunchDirectory", gSystem->WorkingDirectory());
}

const Char_t* KVDataAnalyser::GetBatchStatusFileName() const
{
   // Returns full path to file used to store status of running batch jobs

   if (!BatchMode() || !fBatchEnv) return "";

   static TString filename = "";
   TString statfile;
   statfile.Form("%s.status", gBatchSystem->GetJobName());

   TString launchDir = GetLaunchDirectory();
   AssignAndDelete(filename, gSystem->ConcatFileName(launchDir.Data(), statfile.Data()));
   return filename;
}

void KVDataAnalyser::UpdateBatchStatusFile(Int_t totev, Int_t evread, TString disk) const
{
   // Update infos in batch status file

   if (!BatchMode() || !fBatchEnv) return;

   TEnv stats(GetBatchStatusFileName());
   stats.SetValue("TotalEvents", totev);
   stats.SetValue("EventsRead", evread);
   disk.Remove(TString::kTrailing, '\t');
   disk.Remove(TString::kTrailing, ' ');
   disk.Remove(TString::kTrailing, '\t');
   stats.SetValue("DiskUsed", disk.Data());
   stats.SaveLevel(kEnvLocal);
}

void KVDataAnalyser::DeleteBatchStatusFile() const
{
   // Delete batch status file (and backup - '.bak') for batch job

   if (!BatchMode() || !fBatchEnv) return;
   TString stats = GetBatchStatusFileName();
   gSystem->Unlink(stats);
   stats += ".bak";
   gSystem->Unlink(stats);
}

Bool_t KVDataAnalyser::CheckStatusUpdateInterval(Int_t nevents) const
{
   // Returns kTRUE if the number of events coincides with the interval
   // set for status updates for the current data analysis task
   return (!(nevents % fTask->GetStatusUpdateInterval()) && nevents);
}

void KVDataAnalyser::DoStatusUpdate(Int_t nevents) const
{
   // Print infos on events treated, disk usage, memory usage
   // DEACTIVATED ==> Update status file for batch jobs <==

   cout << " +++ " << nevents << " events processed +++ " << endl;
   ProcInfo_t pid;
   if (gSystem->GetProcInfo(&pid) == 0) {
      TString du = gSystem->GetFromPipe("du -hs");
      TObjArray* toks = du.Tokenize("\t");
      TString disk = ((TObjString*)toks->At(0))->String();
      delete toks;
      cout << "     ------------- Process infos -------------" << endl;
      printf(" CpuUser = %f s.     VirtMem = %f MB      DiskUsed = %s\n",
             pid.fCpuUser, pid.fMemVirtual / 1024., disk.Data());
      // update batch status file with
      // the number of events to read, number of events read, and disk used
      //UpdateBatchStatusFile((Int_t)GetTotalEntriesToRead(),nevents,disk);
   }
}

//__________________________________________________________________________________//

void KVDataAnalyser::ChooseRunningMode()
{
   //Ask user to choose between immediate or batch execution
   //If the choice is batch, we ask to choose a batch system and whether or not
   //to use the "multijobs" mode

   fChoseRunMode = kTRUE;
   KVString tmp;
   do {
      cout << endl << "Run in Interactive or Batch mode (I or B) ? : ";
      tmp.ReadLine(cin);
   } while (tmp != "i" && tmp != "I" && tmp != "b" && tmp != "B");
   tmp.ToUpper();
   //interactive mode - no more to do
   if (tmp == "I") {
      fBatchSystem = 0;
      return;
   }
   cout << endl << "Choose the batch system to use : " << endl;
   gBatchSystemManager->Print();
   do {
      cout << "(enter a number) : " << endl;
      tmp.ReadLine(cin);
   } while (!tmp.IsDigit());
   fBatchSystem = gBatchSystemManager->GetBatchSystem(tmp.Atoi());
   fBatchSystem->Clear();
   do {
      cout << endl << "Single or Multi-job mode (S or M) ? : " << endl;
      tmp.ReadLine(cin);
   } while (tmp != "s" && tmp != "S" && tmp != "m" && tmp != "M");
   tmp.ToUpper();
   fBatchSystem->SetMultiJobsMode(tmp == "M");
}

//__________________________________________________________________________________//

void KVDataAnalyser::ScanWorkingDirectory(TList** ls)
{
   //Fill TList with list of files in current working directory.
   //If ls!=0 it is deleted beforehand
   if (*ls) delete(*ls);
   TSystemDirectory dir("LocDir", gSystem->WorkingDirectory());
   (*ls) = dir.GetListOfFiles();
}

//__________________________________________________________________________________//

void KVDataAnalyser::CopyAnalysisResultsToLaunchDirectory()
{
   //Compare the two lists of files in the current working directory, before and after analysis;
   //and copy any files which were created during the analysis to the launch directory.
   //Files with the same names in the launch directory will be overwritten if they exist.

   if (!fWorkDirInit || !fWorkDirEnd) return;
   TString launchDir = fBatchEnv->GetValue("LaunchDirectory", gSystem->WorkingDirectory());
   TIter next_new_file(fWorkDirEnd);
   TObject* file;
   while ((file = next_new_file())) {
      if (!fWorkDirInit->FindObject(file->GetName())) {
         TString fname;
         fname.Form("%s", file->GetName());
         //ajout d une condition pour eviter le transfert des file*.so generes par les KVParticleCondition
         //et aussi les .d generes par les KVParticleCondition
         if (!(fname.BeginsWith("file") && (fname.EndsWith(".so") || fname.EndsWith(".d")))) {
            TString path_src, path_trg;
            AssignAndDelete(path_trg, gSystem->ConcatFileName(launchDir.Data(), file->GetName()));
            AssignAndDelete(path_src, gSystem->ConcatFileName(gSystem->WorkingDirectory(),
                            file->GetName()));
            Info("CopyAnalysisResultsToLaunchDirectory", "Copying analysis results file :\n%s ---> %s",
                 path_src.Data(), path_trg.Data());
            //copy & overwrite any existing file in launch directory
            if (gSystem->CopyFile(path_src.Data(), path_trg.Data(), kTRUE) == 0) {
               Info("CopyAnalysisResultsToLaunchDirectory", "File copied correctly");
            } else {
               Info("CopyAnalysisResultsToLaunchDirectory", " **** ERROR copying file !!! ");
            }
         }
      }
   }
}

//_________________________________________________________________

void KVDataAnalyser::WriteBatchInfo(TTree* tt)
{
   // Store lots of useful information about the current version of KaliVeda,
   // ROOT, etc. etc. in a TEnv object which will be added to the TTree's
   // list of user infos (TTree::GetUserInfo).

   tt->GetUserInfo()->Add(new TEnv());
   TEnv* kvenv = (TEnv*)tt->GetUserInfo()->FindObject("TEnv");

//----
   THashList* hh = gEnv->GetTable();
   KVString tamp;
   for (Int_t kk = 0; kk < hh->GetEntries(); kk += 1) {
      tamp.Form("%s", hh->At(kk)->GetName());
      if (tamp.BeginsWith("Plugin.")) {}
      else kvenv->SetValue(hh->At(kk)->GetName(), ((TEnvRec*)hh->At(kk))->GetValue(), kEnvUser);
   }

   kvenv->SetValue("KVBase::GetKVVersion()", KVBase::GetKVVersion(), kEnvUser);
   kvenv->SetValue("KVBase::GetKVBuildDate()", KVBase::GetKVBuildDate(), kEnvUser);
   kvenv->SetValue("KVBase::GetKVBuildUser()", KVBase::GetKVBuildUser(), kEnvUser);
   kvenv->SetValue("KVBase::GetKVSourceDir()", KVBase::GetKVSourceDir(), kEnvUser);

#ifdef WITH_BZR_INFOS
   kvenv->SetValue("KVBase::bzrRevisionId()", KVBase::bzrRevisionId(), kEnvUser);
   kvenv->SetValue("KVBase::bzrRevisionDate()", KVBase::bzrRevisionDate(), kEnvUser);
   kvenv->SetValue("KVBase::bzrBranchNick()", KVBase::bzrBranchNick(), kEnvUser);
   kvenv->SetValue("KVBase::bzrRevisionNumber()", KVBase::bzrRevisionNumber());
   kvenv->SetValue("KVBase::bzrIsBranchClean()", KVBase::bzrIsBranchClean());
#endif
#ifdef WITH_GIT_INFOS
   kvenv->SetValue("KVBase::gitBranch()", KVBase::gitBranch(), kEnvUser);
   kvenv->SetValue("KVBase::gitCommit()", KVBase::gitCommit(), kEnvUser);
#endif

   kvenv->SetValue("gROOT->GetVersion()", gROOT->GetVersion(), kEnvUser);

   kvenv->SetValue("gSystem->GetBuildArch()", gSystem->GetBuildArch(), kEnvUser);
   kvenv->SetValue("gSystem->GetBuildCompiler()", gSystem->GetBuildCompiler(), kEnvUser);
   kvenv->SetValue("gSystem->GetBuildCompilerVersion()", gSystem->GetBuildCompilerVersion(), kEnvUser);
   kvenv->SetValue("gSystem->GetBuildNode()", gSystem->GetBuildNode(), kEnvUser);
   kvenv->SetValue("gSystem->GetBuildDir()", gSystem->GetBuildDir(), kEnvUser);

   kvenv->SetValue("gSystem->GetUserInfo()->fUser", gSystem->GetUserInfo()->fUser, kEnvUser);
   kvenv->SetValue("gSystem->HostName()", gSystem->HostName(), kEnvUser);

   if (fBatchEnv) {
      THashList* hh = fBatchEnv->GetTable();
      for (Int_t kk = 0; kk < hh->GetEntries(); kk += 1) {
         tamp.Form("%s", hh->At(kk)->GetName());
         if (!strcmp(kvenv->GetValue(hh->At(kk)->GetName(), "rien"), "rien"))
            kvenv->SetValue(hh->At(kk)->GetName(), ((TEnvRec*)hh->At(kk))->GetValue(), kEnvUser);
      }
   }


}

Int_t KVDataAnalyser::GetRunNumberFromFileName(const Char_t* fileName)
{
   // Get the run number from the filename

   KVAvailableRunsFile* arf;
   arf = GetDataSet()->GetAvailableRunsFile(GetDataType().Data());
   return arf->IsRunFileName(fileName);
}


void KVDataAnalyser::RunAnalyser(const Char_t* uri)
{
   //Set up and run data analysis task.
   //This allows to choose a dataset and a data analysis task and then execute the task or submit a batch job.
   //The behaviour of the data analyser object (base class KVDataAnalyser) can be modified by choosing
   //a plugin class corresponding to one of the plugins defined in $KVROOT/KVFiles/.kvrootrc.

   KVDataAnalyser* datan = 0;
   TString tmp(uri);
   if (tmp != "") {
      //got plugin ?
      TPluginHandler* ph = KVBase::LoadPlugin("KVDataAnalyser", uri);
      if (!ph)
         ::Warning("KVDataAnalyser::RunAnalyser", "No plugin %s found for KVDataAnalyser",
                   uri);
      else
         datan = (KVDataAnalyser*) ph->ExecPlugin(0);
   }
   if (datan == 0)
      datan = new KVDataAnalyser;
   datan->RunMenus();
   delete datan;
}

Bool_t KVDataAnalyser::IsRunningBatchAnalysis()
{
   // Static method KVDataAnalyser::IsRunningBatchAnalysis()
   // Returns kTRUE if an analysis task is being performed in batch mode
   // Returns kFALSE if no analysis task is in interactive mode, or no analysis task running

   if (gDataAnalyser) return (gDataAnalyser->BatchMode() && gDataAnalyser->fBatchSystem);
   return kFALSE;
}

void KVDataAnalyser::AddJobDescriptionList(TList* l)
{
   // Create a KVNameValueList called "JobDescriptionList" and add it to
   // the TList. The parameters in the list describe the properties of the
   // current job. The TList pointer could be, for example, the address of
   // the TSelector::fInput list used by PROOF.

   KVNameValueList* jdl = new KVNameValueList("JobDescriptionList", "Job parameters");

   jdl->SetValue("DataRepository", gDataRepository->GetName());
   jdl->SetValue("DataSet", fDataSet->GetName());
   jdl->SetValue("AnalysisTask", fTask->GetType());
   jdl->SetValue("PROOFMode", GetProofMode());

   l->Add(jdl);
}

